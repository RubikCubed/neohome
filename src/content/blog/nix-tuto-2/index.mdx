---
title: "The Nix lectures, part 2: Derivations"
pubDate: 2024-09-16T07:07:01Z
draft: true
summary: |
  From builtins.derivation to stdenv.mkDerivation, and the language-specific
  builders. All you need to know to start packaging software with Nix.
slug: nix-tuto-2
---

This is part 2 of a tutorial series that covers all of Nix. We covered
language basics in the first part, and in this post we will cover derivations.

import NixTuto from "../../../components/NixTuto.astro";

<NixTuto/>

## builtins.derivation

This is the primitive that Nix uses to define derivations. You will probably
**never** use it, as we rely on higher-level abstractions that are built on top
of `builtins.derivation`.

> [!NOTE]
> Remember that the design of the Nix language, it is a very simple language.
> Having a small API surface means that you don't really have to update the API
> as time passes, but rather the abstractions that are built on top. This is
> useful when you want to use a current Nix binary to evaluate some nixpkgs from
> *many* years ago.

`builtins.derivation` is a function that takes an attrset with some
**known keys**, and the rest are set as environment variables. You can check the
reference documentation in the [nix manual](https://nix.dev/manual/nix/stable/language/derivations).
A simple invocation might look like this:

```nix file: "derivation.nix"
#=> «derivation /nix/store/n34150nf03sh04j8mjzm8sawdqx9sgqi-sample.drv»
```

Derivations can be built in the repl with `:b`, or with the command `nix build
-f derivation.nix`.

Nix will tell use that the return type is a "derivation". However, from chapter
1, I didn't mention that this type exists. What is happening here is that
derivations are implemented as **attrsets** with a special field called `type`.

```nix
{ type = "derivation";  }
#=> «derivation»
```



> [!IMPORTANT]
> **Derivations are attrsets**. We can access fields from derivations, like
> `pkgs.hello.overrideAttrs`. And we can also do **string interpolation**
> because they have an `outPath` field.

Remember, that we can interpolate an attrset if it has an `outPath` field
(string) or a `__toString` field (function).

```nix
pkgs.hello
#=> «derivation /nix/store/crmj28zg09517n5sskml9fmy2c6r3rsr-hello-2.12.1.drv»

pkgs.hello.outPath
#=> "/nix/store/yb84nwgvixzi9sx9nxssq581pc0cc8p3-hello-2.12.1"

"here is ${pkgs.hello}"
#=> "here is /nix/store/yb84nwgvixzi9sx9nxssq581pc0cc8p3-hello-2.12.1"
```

> [!IMPORTANT]
> One one of the key features of Nix is that it has a notion of a *context* for
> a value.
>
> In the previous example, the string has a context because we string
> interpolated a derivation into it. The context of the strings means that it
> depends *at build time* in `pkgs.hello`

```nix file: "two-derivations.nix"
#=> «derivation /nix/store/cbk704h7sffj57hmrp5fm2cs6xpy15nq-second.drv»
```

```console
$ nix build -f ./two-derivations.nix --dry-run
these 2 derivations will be built:
  /nix/store/fasbn3837frywijgjnj33qr51018pyn3-first.drv
  /nix/store/cbk704h7sffj57hmrp5fm2cs6xpy15nq-second.drv
```

This example shows that string interpolation can be used to refer to other
derivation programmatically, and that Nix tracks the references automatically.

### Fixed-output derivations

To be useful, we need Nix to download source code from the internet. As any sane
build system, Nix also implements a *sandbox* that is used during builds. This
sandbox only allows access to:

- `/bin/sh` -- to be able to bootstrap everything.
- `/nix/store` -- deliberate use of other programs in the store
  is not concerning because of the cryptographic hashes.
- "Private" versions of `/proc`, `/dev`, etc.
- Private PID, mount, etc. namespaces.
- **No internet access**

So, how do we handle downloading the source tarballs of projects? In the Nix
"purity" model, we find the concept of a fixed-output derivation, or FOD for
short.

A FOD disables the internet sandbox. However, the user must provide a hash of
the resulting output. If another user tries to build the same FOD, and the hash
is correct, it means the network connection produced the same resulting
derivation.

However, if the resulting derivation doesn't match the provided hash, Nix will
error out. With this system, we allow some "impurity", at the expense of having
to know what the output is. In contrast, for a regular derivation, we don't know
ahead of time the output hash. But we assume, that for the same inputs, the
derivation will produce the same outputs, thanks to the build sandbox. This is
why Nix uses an "input-addressed" model.

99% of the time, you will be using the fetchers from nixpkgs, with
`pkgs.fetchFromGitHub`, etc. But just for the reader to know, that this is
built-in to the language itself, with the `outputHash*` options:

```nix file: "fixed-output.nix"

# $ nix build -f ./fixed-output.nix
# warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA='
# error: hash mismatch in fixed-output derivation '/nix/store/9simizzhrmsq5nnannh8gvgxqm465nwb-fixed-output.drv':
#          specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
#             got:    sha256-3FWguG761jOvjXDVGi2BkN+hLCUurMCBzeF4m0AEr4A=
```

### Building derivations

Nix is an expression-based language, and every nix file must return a single
value. If it returns a derivation, instead of `nix eval`, you use `nix build` to
tell the nix-daemon to build the derivation for you.

`nix build` takes an "installable", which can follow the different types:

- `-f [filename.nix] [attribute]`
- `[flake.nix]#[flake output]`
- `--expr "literal nix expression"`

When using `-f`, instead of returning a derivation, you can return an attrset of
derivations, which you select with the name:

```nix
# filename.nix
{
  foo = builtins.derivation { ... };
  bar = builtins.derivation { ... };
}

# $ nix build -f ./filename.nix foo
```

Some of the flags you should know about are:

- `-L` or `--print-build-logs` -- to make Nix print the build logs.
- `--keep-failed` -- put the working directory somewhere after failing a build.


## stdenv

The standard environment (stdenv for short) is a collection of packages and
build utilities provided by the [nixpkgs](https://github.com/NixOS/nixpkgs)
repository. You can find reference documentation about the stdenv in the
[nixpkgs manual](https://nixos.org/manual/nixpkgs/stable/#part-stdenv).

We can access the stdenv from a `pkgs` instance. Pkgs is **by convention** the
result of calling `import /path/to/nixpkgs {}` (importing nixpkgs and evaluating
with some configuration). Pkgs is a huge attrset that contains all of the
packages, as package name - package value pairs. One of the keys is stdenv.


```nix
let
  # <nixpkgs> is set-up by a regular nix installation
  pkgs = import <nixpkgs> {};
in
  pkgs.stdenv
#=> «derivation /nix/store/sbxnap725qcfsjgp21vjd1h6qpgi6gwj-stdenv-linux.drv»
```

In this section, I don't want to cover stdenv thoughtfully, but rather give you
the topics you will need for a "non-hacker" use. Please refer to the nixpkgs
manual if you want an alternative explanation on these topics.


### mkDerivation basics

`stdenv.mkDerivation` is a function that takes an attrset and returns a
derivation. The arguments of `mkDerivation`, as with `builtins.derivation` are
exported as environment variables. The stdenv builder, a bash script, interprets
the environment variables to build your package.

> [!CAUTION]
> `mkDerivation` doesn't check if the name of the arguments are correct. It will
> silently ignore typos.

An `mkDerivation` call will contain the following:

- `name` or `pname` + `version` of the package. The latter is preferred.
- `src` can be another derivation or a local path.
- Dependencies: packages that our package depends on, at run-time or build-time.
- Phases: pieces of **bash** code.
- Any other environment variable that is used by the builder

`mkDerivation` heavily relies on bash code, and environment variables. As all
the attributes of the argument will be mapped into environment variables, we use
Nix as a "fancy bash writer".

To begin with, `name` is something that is passed-through to
`builtins.derivation`. You can choose to split it with `pname` and `version`,
which is very convenient -- `pname` stands for *package name*.

As mentioned, `src` will be mapped into the environment variable `$src`. The
bash builder has a phase that takes `$src` and tries to unpack it into the work
directory. We can use anything that makes sense where a path does, such as
another derivation. Note that you don't need to manually force the string
interpolation `src = "${myPkg}";`, this is done for you in the `mkDerivation`
implementation.


#### Phases

The `mkDerivation` builder reads different phases, that are either the default
ones, or exported as environment variables, by setting them as attributes to the
call.

The phases are documented in the [nixpkgs manual](https://nixos.org/manual/nixpkgs/stable/#sec-stdenv-phases)
and are the following:

- `unpackPhase` unpacks whatever you put in `src`
- `patchPhase` applies the patches you give with `patches = [ ./my.patch ]`
- `configurePhase` runs `./configure` for autotools-based packages.
- ⭐ `buildPhase` builds the package
- `checkPhase` runs tests
- ⭐ `installPhase` moves files into `$out`
- `fixupPhase` Nix-specific sanity checks, like setting proper store paths
- `installCheckPhase` runs tests that check if the package is installed properly
- `distPhase` -- I have never seen this one in use

> [!IMPORTANT]
> All the phases are implemented in bash. And **not POSIX sh** for the matter, it
> is explicitly bash (if you use the bash extensions).

You can choose to overwrite the default phases. The default implementation of
the phases also run **hooks before and after**, to not have to completely modify
the phase.

```nix
let
  pkgs = import <nixpkgs> {};
in
  pkgs.stdenv.mkDerivation {
    # ...
    patches = [
      ./my.patch
    ];

    postPatch = ''
      # this runs after the standard patchPhase, which applies `patches`
    '';

    buildPhase = ''
      # completely change the build phase
    '';

    postBuild = ''
      # this won't run
      # if you want, you can add `runHook preBuild` and `runHook postBuild`
      # to your custom buildPhase
    '';
  }
```

Many phases also have some configuration. For example, you can control
`unpackPhase` by setting the env variable `dontUnpack`. Refer to the manual for
specifics of each phase.

The default behavior of the stdenv for `buildPhase` and `installPhase` is `make` +
`make install`. If you have a simple C program, then you don't need anything
else. But you probably don't, so let's keep dissecting stdenv.


### Dependencies

The different types of dependencies can be a complex topic. It gets messy when
handling cross-compilation, because you must not mix the different architecures
(e.g. using an x86_64 GCC to build an ARM64 binary).

In Nix, you will use 2 kind of dependencies:

- `nativeBuildInputs` -- packages that are needed on the **build** machine.
  - For example: GCC, make, pkg-config, etc (*usually* programs).
- `buildInputs` -- packages that are needed on the machine that **runs** the
package.
  - For example: libc, QT, zlib, etc (*usually* libraries).

By default, Nix doesn't check that the dependencies do respect this difference,
unless you use `strictDeps = true;`

### Hooks

One of the difference of `nativeBuildInputs`, is that they may contain some bash
code that is sourced by the bash builder. The hook will only be executed if the
package is in `nativeBuildInputs`.

Hooks augment the capabilities of `mkDerivation`, depending on the package.
Usually, they are executed for the program to be able to function properly. This
is best shown by using the example of the hook of `pkg-config`.

`pkg-config` is a program that allows use to find the path to libraries. This is
essential in Nix, because there is no global library path. However, how do we
transmit to `pkg-config`, that the packages in `buildInputs` are available? The
hook is what "glues" everything together. For `pkg-config`, its hook will export
`PKG_CONFIG_PATH`, which is used by the CLI:

```nix file: "pkg-config.nix"
```

```console
$ nix build -f ./pkg-config.nix -L
with-pkg-config> PKG_CONFIG_PATH:/nix/store/0w4q8asq9sn56dl0sxp1m8gk4vy2ygs8-zlib-1.3.1-dev/lib/pkgconfig
with-pkg-config> zlib zlib - zlib compression library
```

### Compiler wrappers

Apart from manually passing the include flags from `pkg-config`, in Nix we also
use the C/C++ compiler wrappers. In general, a wrapper is a "fake" application
that calls the real one, passing some extra arguments.

For Nix, gcc (or clang in macOS) is a bash script. It sets some flags, and then
calls the real gcc.

```console
$ file $(which gcc)
/nix/store/...-gcc-wrapper-13.2.0/bin/gcc: a /nix/store/...-bash-5.2p26/bin/bash script, ASCII text executable

$ tail -n6 $(which gcc)
else
    exec /nix/store/14c6s4xzhy14i2b05s00rjns2j93gzz4-gcc-13.2.0/bin/gcc \
       ${extraBefore+"${extraBefore[@]}"} \
       ${params+"${params[@]}"} \
       ${extraAfter+"${extraAfter[@]}"}
fi
```

The stdenv sets up some flags like `NIX_CFLAGS_COMPILE` or `NIX_LDFLAGS` derived
from `buildInputs`. This makes a "fake global search path", that are passed to
the wrapped gcc. So, if you use `-lz`, gcc will find the library normally,
because the wrapper knows where to find the libraries -- instead of in  `/usr`.

> [!TIP]
> `-isystem` is used for headers, taking precedence over `-I`

```nix file: "cflags.nix"
```

```console
$ nix build -f ./cflags.nix -L
cflags> NIX_CFLAGS_COMPILE= -frandom-seed=4sm1s48afi -isystem /nix/store/0w4q8asq9sn56dl0sxp1m8gk4vy2ygs8-zlib-1.3.1-dev/include -isystem /nix/store/0w4q8asq9sn56dl0sxp1m8gk4vy2ygs8-zlib-1.3.1-dev/include
cflags> NIX_LDFLAGS=-rpath /nix/store/4sm1s48afihxh46mdv71rcwva52w47hm-cflags/lib  -L/nix/store/rqs1zrcncqz3966khjndg1183cpdnqxs-zlib-1.3.1/lib -L/nix/store/rqs1zrcncqz3966khjndg1183cpdnqxs-zlib-1.3.1/lib
```


## Modifying derivations

A very common task in Nix is taking a package, and modifying some of its values.
Usually, you want to upgrade some package to a newer version, or pin it to an
older one. There are multiple ways to do it, which will be explained in the
following sections.

### overrideAttrs

When you use `mkDerivation`, the resulting derivation will contain an extra
attribute named `.overrideAttrs`. This is a function that takes a function as an
argument `.overrideAttrs fn`. The function argument, takes the old
`mkDerivation` arguments, and can output **some** of the new arguments. I
believe it is best understood with an example:

```nix
let
  pkgs = import <nixpkgs> {};
in
  pkgs.hello.overrideAttrs (old: {
    pname = "goodbye";
  })
#=> «derivation /nix/store/0b00bv1hjv7v1dlnzgrv21caz4h7ihii-goodbye-2.12.1.drv»
```

Of course, it is possible to chain multiple `.overrideAttrs`, but it would be
silly: `((pkgs.hello.overrideAttrs fn1).overrideAttrs fn2).overrideAttrs fn3`.

A common task would be to generate a new package that changes the version to an
updated one, or using a different fork of the project.

+ Change the `src` to a different one
+ Optionally change `version` or `pname`. Note that these are only useful to
humans, Nix doesn't use them.
+ If the build process changed, adapt the package by tweaking the different
phases.
+ Optionally, change ony other attributes, like `patches` or `buildInputs`

```nix
let
  pkgs = import <nixpkgs> {};
in
  pkgs.hello.overrideAttrs (old: {
    # using the old attributes
    pname = old.pname + "-mod";

    # changing to a different version/fork
    src = pkgs.fetchFromGitHub { ... };

    # adjusting your dependencies
    buildInputs = old.buildInputs ++ [ pkgs.zlib ];

    postInstall = ''
      # run extra code after installation, etc
    '';
  })
```

### override and callPackage pattern

Overriding a package can be very nuanced. In the previous example, it can be
hard to control which dependencies are used.

Let's imagine that `pkgs.hello` depended on `pkgs.zlib`. How could we change
which `pkgs.zlib` is used, only with `.overrideAttrs`? You could imagine doing
something like:

```nix
# we don't do this
buildInputs = (builtins.filter (drv: (lib.getName drv) != "zlib")) ++ [ newZlib
];
```

This can be impossible, if we are "consuming" `zlib` in a "non-structured"
manner, for example doing string interpolation.

The solution that nixpkgs proposes is the `callPackage` pattern.
`pkgs.callPackage file args` takes a function f, and calls it with `pkgs // args`
-- this is, with your custom modifications in args.


```nix
# package.nix
{
  stdenv,
  zlib,
}: stdenv.mkDerivation {
  name = "foo";
  buildPhase = ''
    echo ${zlib} > $out
  '';
  # ...
}

# default.nix
let
  pkgs = import <nixpkgs> {};
in
  # calls package.nix with pkgs.stdenv and pkgs.zlib automatically
  pkgs.callPackage ./package.nix {}
```

What `callPackage` lets us do, is to pass our custom `zlib` via its arguments,
or rather with `override`:

```nix
# default.nix
let
  pkgs = import <nixpkgs> {};
  myZlib = pkgs.zlib.overrideAttrs ...; # custom zlib

  myPkg = pkgs.callPackage ./package.nix {
    zlib = myZlib;
  };
  # or with override
  myPkg2 = myPkg.override {
    zlib = ...;
  };
in
  # ...
```

> [!IMPORTANT]
> In summary:
> - `.overrideAttrs` can be used to change the arguments of `mkDerivation`
> - `.override` can be used to inject different dependencies when used with
>   `callPackage` -- ideally you always use `callPackage`.


## Package collections

In the previous sections we have learn:

- The basics of derivations
- Using `mkDerivation` as an abstraction
- Modifying packages with `.overrideAttrs`
- Using `callPackage` and `.override` for dependency injection

The next step, is learning how to handle a collection of different packages, and
threading the dependencies between them. We will start with a simple example:
we have 3 packages that depend on each other:

- `myLib`
- `simpleCLI`, that depends on `myLib`
- `complexCLI`, that depends on `myLib` and `simpleCLI`

We will use `pkgs.callPackage` which passes `pkgs` to the arguments. But,
because these 3 new packages are not in nixpkgs, we will need to pass the
explicitely:

```nix
let
  pkgs = import <nixpkgs> {};

  myLib = pkgs.callPackage ./package-mylib {};
  simpleCLI = pkgs.callPackage ./package-simplecli {
    inherit myLib;
  };
  complexCLI = pkgs.callPackage ./package-complexcli {
    inherit myLib simpleCLI;
  };
in
  # ...
```

This manual "threading" of dependencies is fine for 1 or 2 packages, but it will
become annoying quickly. To solve this, there are two different solutions.

### callPackageWith

As you know, `pkgs.callPackage file args` will call the `file` with `(pkgs //
args)`. `callPackageWith` is simply a way to define what we want to call the
packages with, as the name implies.

First, you define your own custom `callPackage`:

```nix
myCallPackage = pkgs.callPackageWith (pkgs // mypkgs);
```

And then, simply use it to define your package set. It may look like an
infinite-recursion or self-referencing problem, but Nix can deal with it no
problem. All your dependencies will be threaded automatically with your custom
`callPackage`.

```nix
let
  pkgs = import <nixpkgs> {};
  myCallPackage = pkgs.callPackageWith (pkgs // mypkgs);

  mypkgs = {
    myLib = myCallPackage ./package-mylib {};
    simpleCLI = myCallPackage ./package-simplecli {}; # myLib passed automatically
    complexCLI = myCallPackage ./package-complexcli {}; # " and simpleCLI passed too
  };
```


### overlays

Overlays is one of the "buzzwords" that you may have heard from Nix. But if you
have reached here, then you have all the knowledge to understand what overlays
are used for.

Similarly to the `callPackageWith` pattern described before, overlays allow to
inject our package collection into `pkgs` itself. Instead of using a custom
`callPackage` that threads our custom packages, we are "modifying" `pkgs`
itself.

Overlays are loaded when importing nixpkgs. An overlay is a function that takes
2 arguments:

> [!TIP]
> Function arguments are named by the user. You may see other names used for
> overlays.

```nix
final: prev: {
  myLib = final.callPackage ./package-mylb.nix {};

  # myLib passed automatically from final
  # because it's on final.myLib
  simpleCLI = final.callPackage ./package-simplecli {};
  complexCLI = final.callPackage ./package-complexcli {}; # " and simpleCLI passed too

  # you can also modify pkgs from nixpkgs
  # this will be final.zlib, so modify zlib from prev
  zlib = prev.zlib.overrideAttrs ....;
}
```

Both `prev` and `final` are like `pkgs` -- that is, a huge attrset containing
all the packages. `prev` is `pkgs` before applying your overlay. `final` is
`pkgs` after applying all overlays, including the one you are writing.

It should not come as a surprise, that in Nix we can use the result of a
function, as the argument to itself. It's possible due to lazy evaluation, but
you don't need to thing too hard about it.

When should you grab something from `prev` and when from `final`? The rule of
thumb is the following:

- Take from `prev` what you want to modify, e.g. `pkg = prev.pkg.overrideAttrs
...`
- Take from `final` otherwise. As it will account for every modification from
every package. We use `final.callPackage` to thread the modifications of our
overlay.


## Trivial builders


## Language frameworks
